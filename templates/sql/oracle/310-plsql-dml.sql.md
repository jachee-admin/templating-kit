###### Oracle PL/SQL
### PL/SQL DML 19c — inserts, updates, merges, deletes (feature buffet)

Below is a compact but complete set of patterns. **Yes**: `INSERT ALL` / `INSERT FIRST` are *multi-table inserts* and **always** require a trailing `SELECT …` query. If you’re inserting literal/bind values, the minimal form ends with `SELECT … FROM DUAL`.

---

## 0) Setup (run once for demos)
```sql
CREATE TABLE accounts (
  account_id     NUMBER GENERATED BY DEFAULT AS IDENTITY,
  email          VARCHAR2(320) UNIQUE,
  full_name      VARCHAR2(200),
  created_at     TIMESTAMP DEFAULT SYSTIMESTAMP,
  updated_at     TIMESTAMP,
  prefs_json     CLOB CHECK (prefs_json IS JSON)
);

CREATE TABLE orders (
  order_id       NUMBER GENERATED BY DEFAULT AS IDENTITY,
  account_id     NUMBER NOT NULL,
  total_cents    NUMBER(12,0) DEFAULT 0,
  created_at     TIMESTAMP DEFAULT SYSTIMESTAMP,
  processed      CHAR(1) DEFAULT 'N',
  CONSTRAINT orders_fk_accounts
    FOREIGN KEY (account_id) REFERENCES accounts(account_id)
);

BEGIN
  DBMS_ERRLOG.CREATE_ERROR_LOG('ACCOUNTS');
  DBMS_ERRLOG.CREATE_ERROR_LOG('ORDERS');
END;
/
````

---

## 1) INSERT — single row, identity, RETURNING

```sql
DECLARE
  v_id      accounts.account_id%TYPE;
  v_created TIMESTAMP;
BEGIN
  INSERT INTO accounts (email, full_name)
  VALUES ('ada@nc.gov', 'Ada Lovelace')
  RETURNING account_id, created_at INTO v_id, v_created;

  DBMS_OUTPUT.PUT_LINE('new account_id='||v_id||' created_at='||
                       TO_CHAR(v_created,'YYYY-MM-DD HH24:MI:SS'));
END;
/
```

### 1a) INSERT with explicit sequence

```sql
CREATE SEQUENCE acct_seq START WITH 1001;
INSERT INTO accounts (account_id, email, full_name)
VALUES (acct_seq.NEXTVAL, 'grace@nc.gov', 'Grace Hopper');
```

---

## 2) **INSERT ALL / INSERT FIRST** — multi-table inserts

**Key facts**

* Syntax is `INSERT ALL … SELECT …` (or `INSERT FIRST … SELECT …`).
* The `SELECT` can be from `DUAL` (for literals/binds) **or** a real source (applied per source row).
* `INSERT ALL` applies **all matching** `WHEN` clauses; `INSERT FIRST` applies only the **first matching** `WHEN`.
* `RETURNING` is **not** supported with multi-table inserts.

### 2a) Unconditional multi-table insert (literals/binds) — minimal form

```sql
INSERT ALL
  INTO accounts (email, full_name) VALUES ('multi@nc.gov', 'Multi Insert')
  INTO orders   (account_id, total_cents) VALUES (1, 9999)
SELECT 1 FROM dual;
```

### 2b) Conditional multi-insert with `WHEN` (bind-driven)

```sql
VAR p_amount NUMBER; EXEC :p_amount := 12000;
VAR p_acct   NUMBER; EXEC :p_acct   := 1;

INSERT ALL
  WHEN :p_amount >= 10000 THEN
    INTO orders (account_id, total_cents) VALUES (:p_acct, :p_amount)
  WHEN :p_amount BETWEEN 5000 AND 9999 THEN
    INTO orders (account_id, total_cents) VALUES (:p_acct, :p_amount)
  ELSE
    INTO orders (account_id, total_cents) VALUES (:p_acct, 0)
SELECT 1 FROM dual;
```

### 2c) Data-driven multi-insert (applies per source row)

```sql
-- For every row selected, evaluate WHENs and insert accordingly
INSERT ALL
  WHEN cents >= 50000 THEN INTO orders(account_id, total_cents) VALUES (account_id, cents)
  WHEN cents >= 10000 THEN INTO orders(account_id, total_cents) VALUES (account_id, cents)
  ELSE                     INTO orders(account_id, total_cents) VALUES (account_id, 0)
SELECT a.account_id, ROUND(DBMS_RANDOM.VALUE(1000,90000)) AS cents
FROM   accounts a
WHERE  a.email LIKE 'a%';
```

### 2d) `INSERT FIRST` (stop at first match)

```sql
INSERT FIRST
  WHEN cents >= 50000 THEN INTO orders(account_id, total_cents) VALUES (account_id, cents)
  WHEN cents >= 10000 THEN INTO orders(account_id, total_cents) VALUES (account_id, cents)
  ELSE                     INTO orders(account_id, total_cents) VALUES (account_id, 0)
SELECT a.account_id, ROUND(DBMS_RANDOM.VALUE(1000,90000)) AS cents
FROM   accounts a;
```

---

## 3) INSERT /*+ APPEND */ + LOG ERRORS — fast bulk

```sql
INSERT /*+ APPEND */ INTO accounts (email, full_name)
SELECT email, full_name
FROM   staging_accounts
LOG ERRORS INTO ERR$_ACCOUNTS ('BULK_LOAD') REJECT LIMIT UNLIMITED;
```

---

## 4) UPDATE — joined update via scalar subquery

```sql
UPDATE accounts a
SET    full_name = (SELECT MAX(u.full_name) FROM user_directory u WHERE u.email = a.email),
       updated_at = SYSTIMESTAMP
WHERE  EXISTS (SELECT 1 FROM user_directory u WHERE u.email = a.email);
```

### 4a) UPDATE JSON (19c)

```sql
UPDATE accounts
SET    prefs_json = JSON_MERGEPATCH(prefs_json, '{"newsletter":true,"theme":"dark"}')
WHERE  email = 'ada@nc.gov';
```

### 4b) UPDATE with RETURNING

```sql
DECLARE
  v_new_name  accounts.full_name%TYPE;
  v_updated   TIMESTAMP;
BEGIN
  UPDATE accounts
  SET    full_name = 'Ada Byron',
         updated_at = SYSTIMESTAMP
  WHERE  email = 'ada@nc.gov'
  RETURNING full_name, updated_at INTO v_new_name, v_updated;
END;
/
```

---

## 5) DELETE — predicates, anti-joins, RETURNING

```sql
DELETE FROM orders
WHERE  processed = 'Y' AND created_at < SYSTIMESTAMP - INTERVAL '90' DAY;

DECLARE v_id orders.order_id%TYPE;
BEGIN
  DELETE FROM orders WHERE order_id = 123 RETURNING order_id INTO v_id;
END;
/
```

```sql
-- Anti-join cleanup
DELETE FROM accounts a
WHERE  NOT EXISTS (SELECT 1 FROM orders o WHERE o.account_id = a.account_id)
AND    a.created_at < SYSTIMESTAMP - INTERVAL '365' DAY;
```

---

## 6) MERGE — canonical upsert

```sql
MERGE INTO accounts d
USING (SELECT :email AS email, :name AS full_name FROM dual) s
ON (d.email = s.email)
WHEN MATCHED THEN
  UPDATE SET d.full_name = s.full_name, d.updated_at = SYSTIMESTAMP
WHEN NOT MATCHED THEN
  INSERT (email, full_name, created_at)
  VALUES (s.email, s.full_name, SYSTIMESTAMP);
```

### 6a) MERGE with `DELETE WHERE` to sync sets

```sql
MERGE INTO orders d
USING (SELECT order_id, account_id, total_cents FROM orders_stage) s
ON (d.order_id = s.order_id)
WHEN MATCHED THEN
  UPDATE SET d.total_cents = s.total_cents
WHEN NOT MATCHED THEN
  INSERT (order_id, account_id, total_cents)
  VALUES (s.order_id, s.account_id, s.total_cents)
WHEN NOT MATCHED BY SOURCE THEN
  DELETE WHERE d.created_at < SYSTIMESTAMP - INTERVAL '30' DAY; -- guard
```

---

## 7) Error-resilient batch DML — LOG ERRORS + SAVE EXCEPTIONS

```sql
DECLARE
  TYPE t_emails IS TABLE OF VARCHAR2(320);
  v_emails t_emails := t_emails('ok1@nc.gov','dup@nc.gov','bad@bad@nc.gov');
BEGIN
  FOR i IN 1 .. v_emails.COUNT LOOP
    BEGIN
      INSERT INTO accounts (email, full_name)
      VALUES (v_emails(i), 'Bulk Insert')
      LOG ERRORS INTO ERR$_ACCOUNTS ('BATCH') REJECT LIMIT UNLIMITED;
    EXCEPTION WHEN OTHERS THEN NULL; -- captured in ERR$_
    END;
  END LOOP;
END;
/
```

```sql
DECLARE
  TYPE t_ids IS TABLE OF orders.order_id%TYPE;
  v_ids t_ids := t_ids(1,2,3,4,5);
BEGIN
  BEGIN
    FORALL i IN v_ids.FIRST .. v_ids.LAST SAVE EXCEPTIONS
      UPDATE orders SET processed='Y', created_at=created_at WHERE order_id = v_ids(i);
  EXCEPTION
    WHEN OTHERS THEN
      FOR j IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('idx='||SQL%BULK_EXCEPTIONS(j).ERROR_INDEX||
                             ' code='||SQL%BULK_EXCEPTIONS(j).ERROR_CODE);
      END LOOP;
  END;
  COMMIT;
END;
/
```

---

## 8) RETURNING into collections (multi-row)

```sql
DECLARE
  TYPE t_id_tab IS TABLE OF orders.order_id%TYPE;
  v_ids t_id_tab;
BEGIN
  INSERT INTO orders (account_id, total_cents)
  SELECT a.account_id, 12345
  FROM   accounts a
  WHERE  a.email LIKE 'a%'
  RETURNING order_id BULK COLLECT INTO v_ids;

  DBMS_OUTPUT.PUT_LINE('#inserted='||v_ids.COUNT);
END;
/
```

---

## 9) Row limiting helper (delete oldest N)

```sql
DELETE FROM orders
WHERE  order_id IN (
  SELECT order_id
  FROM   orders
  WHERE  processed = 'Y'
  ORDER  BY created_at
  FETCH FIRST 100 ROWS ONLY
);
```

---

## 10) JSON_TABLE upsert (denormalize from JSON)

```sql
DECLARE
  v_json CLOB := '{
    "email":"json.user@nc.gov",
    "name":"Json User",
    "orders":[{"cents":1500},{"cents":2500}]
  }';
BEGIN
  MERGE INTO accounts d
  USING (
    SELECT jt.email, jt.full_name
    FROM   JSON_TABLE(v_json, '$'
           COLUMNS ( email     VARCHAR2(320) PATH '$.email'
                   , full_name VARCHAR2(200) PATH '$.name')) jt
  ) s
  ON (d.email = s.email)
  WHEN MATCHED THEN UPDATE SET d.full_name = s.full_name, d.updated_at = SYSTIMESTAMP
  WHEN NOT MATCHED THEN INSERT (email, full_name) VALUES (s.email, s.full_name);

  INSERT INTO orders (account_id, total_cents)
  SELECT a.account_id, o.cents
  FROM   accounts a
  CROSS JOIN JSON_TABLE(v_json, '$.orders[*]' COLUMNS (cents NUMBER PATH '$.cents')) o
  WHERE  a.email = JSON_VALUE(v_json, '$.email');

  COMMIT;
END;
/
```

---

## 11) Handy hints (use sparingly when testing alternatives)

```sql
-- Force path for testing:
SELECT /*+ INDEX(a ACCOUNTS_EMAIL_UK) */ * FROM accounts a WHERE a.email = :b1;
SELECT /*+ FULL(a) */ * FROM accounts a WHERE a.email = :b1;

-- Direct-path insert with parallel
INSERT /*+ APPEND PARALLEL(orders 4) */ INTO orders (account_id, total_cents)
SELECT account_id, 100 FROM accounts;
```
```yaml
---
id: templates/sql/oracle/310-plsql-dml.sql.md
lang: sql
platform: oracle
scope: plsql
since: "v0.4"
tested_on: "Oracle 19c"
tags: [plsql, dml, insert, update, delete, merge, returning, error-logging, json, identity, sequence, parallel, insert-all]
description: "Modern Oracle 19c DML: INSERT (single, multi-table INSERT ALL/FIRST, APPEND, RETURNING), UPDATE (joins, JSON), DELETE (RETURNING, cascades), MERGE (upserts), plus error logging and batch patterns."
---
```