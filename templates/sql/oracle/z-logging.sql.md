---
id: sql/oracle/plsql/generic-logging-19c
lang: sql
platform: oracle
scope: plsql
since: "v0.6"
tested_on: "Oracle 19c"
tags: [plsql, logging, autonomous_transaction, dbms_utility, dbms_application_info, json, purge]
description: "Drop-in, schema-local logging: table + indexes, an autonomous logger package with levels (DEBUG/INFO/WARN/ERROR), correlation IDs, context capture (module/action/client_identifier), exception helpers, JSON context, and retention purge."
---
###### Oracle PL/SQL
### Generic Logging (drop-in, schema-local) — 19c
Self-contained logging you can paste into any schema. No hardcoded schema names; uses identity PKs, an autonomous transaction for durability, optional JSON context, and a simple purge routine.

---

## 1) Table & indexes (create once)

```sql
-- Core event table (schema-local)
CREATE TABLE log_event (
  id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ts              TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  level           VARCHAR2(10)  NOT NULL,    -- DEBUG/INFO/WARN/ERROR
  module          VARCHAR2(64),              -- from DBMS_APPLICATION_INFO or caller
  action          VARCHAR2(64),
  tag             VARCHAR2(64),              -- freeform tag (e.g., domain, job name)
  correlation_id  VARCHAR2(64),              -- end-to-end correlation
  user_name       VARCHAR2(128) DEFAULT SYS_CONTEXT('USERENV','SESSION_USER'),
  client_id       VARCHAR2(256) DEFAULT SYS_CONTEXT('USERENV','CLIENT_IDENTIFIER'),
  host            VARCHAR2(256) DEFAULT SYS_CONTEXT('USERENV','HOST'),
  ip              VARCHAR2(64)  DEFAULT SYS_CONTEXT('USERENV','IP_ADDRESS'),
  sid             VARCHAR2(64)  DEFAULT SYS_CONTEXT('USERENV','SID'),
  instance_name   VARCHAR2(64)  DEFAULT SYS_CONTEXT('USERENV','INSTANCE_NAME'),
  msg             CLOB,                      -- human-readable message
  err_code        NUMBER,                    -- -20000.. or ORA- codes
  err_stack       CLOB,                      -- DBMS_UTILITY.format_error_stack
  err_backtrace   CLOB,                      -- DBMS_UTILITY.format_error_backtrace
  ctx_json        CLOB CHECK (ctx_json IS JSON)  -- optional structured context
);

-- Helpful indexes (tune to taste)
CREATE INDEX log_event_ix1 ON log_event (level, ts DESC);
CREATE INDEX log_event_ix2 ON log_event (module, action, ts DESC);
CREATE INDEX log_event_ix3 ON log_event (correlation_id, ts DESC);
````

---

## 2) Package spec — `LOG_` (simple, durable, flexible)

```sql
CREATE OR REPLACE PACKAGE log_ AS
  -- Severity constants
  c_debug CONSTANT VARCHAR2(10) := 'DEBUG';
  c_info  CONSTANT VARCHAR2(10) := 'INFO';
  c_warn  CONSTANT VARCHAR2(10) := 'WARN';
  c_error CONSTANT VARCHAR2(10) := 'ERROR';

  -- Set or get correlation id (uses CLIENT_IDENTIFIER under the hood)
  PROCEDURE set_correlation_id(p_id IN VARCHAR2 DEFAULT NULL);
  FUNCTION  get_correlation_id RETURN VARCHAR2;

  -- Set module/action for the session (DBMS_APPLICATION_INFO)
  PROCEDURE set_module_action(p_module IN VARCHAR2, p_action IN VARCHAR2 DEFAULT NULL);

  -- Generic logger (message + optional JSON context)
  PROCEDURE write(
    p_level          IN VARCHAR2,
    p_msg            IN CLOB,
    p_tag            IN VARCHAR2   DEFAULT NULL,
    p_module         IN VARCHAR2   DEFAULT NULL,
    p_action         IN VARCHAR2   DEFAULT NULL,
    p_ctx_json       IN CLOB       DEFAULT NULL,
    p_correlation_id IN VARCHAR2   DEFAULT NULL
  );

  -- Level-specific convenience wrappers
  PROCEDURE debug(p_msg IN CLOB, p_tag IN VARCHAR2 DEFAULT NULL, p_ctx_json IN CLOB DEFAULT NULL);
  PROCEDURE info (p_msg IN CLOB, p_tag IN VARCHAR2 DEFAULT NULL, p_ctx_json IN CLOB DEFAULT NULL);
  PROCEDURE warn (p_msg IN CLOB, p_tag IN VARCHAR2 DEFAULT NULL, p_ctx_json IN CLOB DEFAULT NULL);
  PROCEDURE error(p_msg IN CLOB, p_tag IN VARCHAR2 DEFAULT NULL, p_ctx_json IN CLOB DEFAULT NULL);

  -- Log current exception with stack/backtrace; optional tag/json; re-raise toggle
  PROCEDURE log_exception(
    p_tag            IN VARCHAR2 DEFAULT NULL,
    p_ctx_json       IN CLOB     DEFAULT NULL,
    p_correlation_id IN VARCHAR2 DEFAULT NULL,
    p_reraise        IN BOOLEAN  DEFAULT TRUE
  );

  -- Purge old rows (default 30 days)
  PROCEDURE purge_older_than(p_days IN PLS_INTEGER DEFAULT 30);
END log_;
/
```

---

## 3) Package body — autonomous transaction logger

```sql
CREATE OR REPLACE PACKAGE BODY log_ AS

  PROCEDURE set_correlation_id(p_id IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    DBMS_SESSION.SET_IDENTIFIER(COALESCE(p_id, RAWTOHEX(SYS_GUID())));
  END;

  FUNCTION get_correlation_id RETURN VARCHAR2 IS
  BEGIN
    RETURN SYS_CONTEXT('USERENV','CLIENT_IDENTIFIER');
  END;

  PROCEDURE set_module_action(p_module IN VARCHAR2, p_action IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    DBMS_APPLICATION_INFO.SET_MODULE(p_module, p_action);
  END;

  -- Core write (autonomous: survives caller rollback)
  PROCEDURE write(
    p_level          IN VARCHAR2,
    p_msg            IN CLOB,
    p_tag            IN VARCHAR2   DEFAULT NULL,
    p_module         IN VARCHAR2   DEFAULT NULL,
    p_action         IN VARCHAR2   DEFAULT NULL,
    p_ctx_json       IN CLOB       DEFAULT NULL,
    p_correlation_id IN VARCHAR2   DEFAULT NULL
  ) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    v_level VARCHAR2(10) := UPPER(p_level);
    v_mod   VARCHAR2(64) := COALESCE(p_module, SYS_CONTEXT('USERENV','MODULE'));
    v_act   VARCHAR2(64) := COALESCE(p_action, SYS_CONTEXT('USERENV','ACTION'));
    v_corr  VARCHAR2(64) := COALESCE(p_correlation_id, get_correlation_id);
  BEGIN
    INSERT INTO log_event(level, module, action, tag, correlation_id, msg, ctx_json)
    VALUES (v_level, v_mod, v_act, p_tag, v_corr, p_msg, p_ctx_json);
    COMMIT;
  EXCEPTION WHEN OTHERS THEN
    -- Failsafe: last-ditch effort without CLOB context if JSON invalid/etc.
    BEGIN
      INSERT INTO log_event(level, module, action, tag, correlation_id, msg)
      VALUES ('ERROR', 'LOG_', 'WRITE', 'LOGGER', v_corr,
              'Logger write failed: '||SQLERRM);
      COMMIT;
    EXCEPTION WHEN OTHERS THEN NULL; END;
  END write;

  PROCEDURE debug(p_msg IN CLOB, p_tag IN VARCHAR2 DEFAULT NULL, p_ctx_json IN CLOB DEFAULT NULL) IS
  BEGIN write(c_debug, p_msg, p_tag, NULL, NULL, p_ctx_json, NULL); END;
  PROCEDURE info (p_msg IN CLOB, p_tag IN VARCHAR2 DEFAULT NULL, p_ctx_json IN CLOB DEFAULT NULL) IS
  BEGIN write(c_info , p_msg, p_tag, NULL, NULL, p_ctx_json, NULL); END;
  PROCEDURE warn (p_msg IN CLOB, p_tag IN VARCHAR2 DEFAULT NULL, p_ctx_json IN CLOB DEFAULT NULL) IS
  BEGIN write(c_warn , p_msg, p_tag, NULL, NULL, p_ctx_json, NULL); END;
  PROCEDURE error(p_msg IN CLOB, p_tag IN VARCHAR2 DEFAULT NULL, p_ctx_json IN CLOB DEFAULT NULL) IS
  BEGIN write(c_error, p_msg, p_tag, NULL, NULL, p_ctx_json, NULL); END;

  PROCEDURE log_exception(
    p_tag            IN VARCHAR2 DEFAULT NULL,
    p_ctx_json       IN CLOB     DEFAULT NULL,
    p_correlation_id IN VARCHAR2 DEFAULT NULL,
    p_reraise        IN BOOLEAN  DEFAULT TRUE
  ) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    v_mod  VARCHAR2(64) := SYS_CONTEXT('USERENV','MODULE');
    v_act  VARCHAR2(64) := SYS_CONTEXT('USERENV','ACTION');
    v_corr VARCHAR2(64) := COALESCE(p_correlation_id, get_correlation_id);
    v_code NUMBER       := SQLCODE;
    v_stack CLOB        := DBMS_UTILITY.format_error_stack;
    v_bt    CLOB        := DBMS_UTILITY.format_error_backtrace;
  BEGIN
    INSERT INTO log_event(level, module, action, tag, correlation_id,
                          msg, err_code, err_stack, err_backtrace, ctx_json)
    VALUES (c_error, v_mod, v_act, p_tag, v_corr,
            'Exception: '||SQLERRM, v_code, v_stack, v_bt, p_ctx_json);
    COMMIT;

    IF p_reraise THEN
      RAISE; -- preserve original error
    END IF;
  EXCEPTION WHEN OTHERS THEN
    -- As a last resort, don’t mask caller’s failure
    IF p_reraise THEN RAISE; END IF;
  END log_exception;

  PROCEDURE purge_older_than(p_days IN PLS_INTEGER DEFAULT 30) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    DELETE FROM log_event
    WHERE ts < SYSTIMESTAMP - NUMTODSINTERVAL(p_days, 'DAY');
    COMMIT;
  END purge_older_than;

END log_;
/
```

---

## 4) Usage examples

### 4.1) Basic logging with module/action + correlation

```sql
BEGIN
  log_.set_module_action('APEX:Job', 'Kickoff');
  log_.set_correlation_id; -- auto GUID
  log_.info('Job starting', p_tag => 'job:daily');
END;
/
```

### 4.2) Log JSON context (parameters, payloads)

```sql
DECLARE
  v_ctx CLOB := '{"wf":"onboard","account_id":123,"dry_run":false}';
BEGIN
  log_.debug('Dispatching workflow', p_tag => 'ansible', p_ctx_json => v_ctx);
END;
/
```

### 4.3) Capture and re-raise exceptions with full stack

```sql
BEGIN
  -- your code
  RAISE_APPLICATION_ERROR(-20001, 'Kaboom');
EXCEPTION
  WHEN OTHERS THEN
    log_.log_exception(p_tag => 'onboard'); -- logs + re-raises by default
END;
/
```

### 4.4) Swallow after logging (set `p_reraise => FALSE`)

```sql
BEGIN
  -- risky but non-critical
  NULL;
EXCEPTION
  WHEN OTHERS THEN
    log_.log_exception(p_tag => 'noncritical', p_reraise => FALSE);
END;
/
```

### 4.5) Purge old logs (e.g., weekly job)

```sql
BEGIN
  log_.purge_older_than(60); -- keep 60 days
END;
/
```

---

## 5) Nice-to-haves (optional, paste if useful)

### 5.1) Pretty view (trim big CLOBs for quick browsing)

```sql
CREATE OR REPLACE VIEW v_log_event AS
SELECT id, ts, level, module, action, tag, correlation_id, user_name,
       SUBSTR(msg, 1, 400) AS msg_400,
       err_code,
       CASE WHEN err_stack IS NOT NULL THEN 'Y' END AS has_err,
       CASE WHEN ctx_json IS NOT NULL THEN 'Y' END AS has_ctx
FROM   log_event
ORDER  BY ts DESC;
```

### 5.2) Sample policy: cap DEBUG in prod (toggle by context)

```sql
-- Example pattern: in your app code, only write DEBUG if a feature flag is on
IF SYS_CONTEXT('USERENV','MODULE') LIKE 'DEV%' THEN
  log_.debug('verbose detail...', p_tag => 'dev');
END IF;
```

---

## 6) Notes & design choices

* **Durability:** `PRAGMA AUTONOMOUS_TRANSACTION` ensures logs survive caller rollback (by design).
* **Zero schema coupling:** no schema names; identity PK keeps it simple.
* **Observability:** captures `module`, `action`, `client_identifier`, host, IP, etc.
* **Correlation:** use `log_.set_correlation_id` at entry points (APEX request, batch job, integration).
* **JSON context:** optional, validated by `CHECK (ctx_json IS JSON)` for quick, structured breadcrumbs.
* **Performance:** narrow indexes on access paths; avoid over-indexing CLOBs. For very high volume, consider partitioning by day/week and local indexes.

