---
id: sql/oracle/plsql/triggers-19c
lang: sql
platform: oracle
scope: plsql
since: "v0.12"
tested_on: "Oracle 19c"
tags: [plsql, triggers, row-level, statement-level, compound-trigger, instead-of, ddl-trigger, audit, follows, mutating-table, validation]
description: "Trigger patterns in Oracle 19c: BEFORE/AFTER row & statement triggers, INSTEAD OF (views), COMPOUND triggers to avoid mutating-table errors, auditing/change-log, validation, sequencing, DDL & LOGON triggers, and operational tips."
---
###### Oracle PL/SQL
### Triggers — practical examples & usage (Oracle 19c)
Use declarative constraints first. Reach for triggers when you *must* enforce cross-row logic, audit changes, integrate, or maintain denormalized data. Prefer **compound triggers** to dodge mutating-table problems.

---

## 0) Setup demo tables

```sql
CREATE TABLE accounts (
  account_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email        VARCHAR2(320) UNIQUE NOT NULL,
  full_name    VARCHAR2(200),
  status       VARCHAR2(10) DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE','BLOCKED')),
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  updated_at   TIMESTAMP
);

CREATE TABLE orders (
  order_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  account_id   NUMBER NOT NULL REFERENCES accounts(account_id),
  total_cents  NUMBER(12,0) DEFAULT 0,
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL
);

CREATE TABLE account_audit (
  audit_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  account_id   NUMBER,
  op           VARCHAR2(10),
  changed_by   VARCHAR2(128) DEFAULT SYS_CONTEXT('USERENV','SESSION_USER'),
  changed_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  old_email    VARCHAR2(320),
  new_email    VARCHAR2(320),
  old_name     VARCHAR2(200),
  new_name     VARCHAR2(200),
  old_status   VARCHAR2(10),
  new_status   VARCHAR2(10)
);
````

---

## 1) Row-level BEFORE trigger — normalize & validate

```sql
CREATE OR REPLACE TRIGGER biu_accounts_norm
BEFORE INSERT OR UPDATE ON accounts
FOR EACH ROW
DECLARE
  PROCEDURE assert_email(p IN VARCHAR2) IS
  BEGIN
    IF p IS NULL OR INSTR(p,'@') = 0 THEN
      RAISE_APPLICATION_ERROR(-20001,'Invalid email');
    END IF;
  END;
BEGIN
  -- Normalize
  :NEW.email := LOWER(TRIM(:NEW.email));
  :NEW.full_name := TRIM(:NEW.full_name);

  -- Validation
  assert_email(:NEW.email);

  -- Timestamps
  IF INSERTING THEN
    :NEW.created_at := COALESCE(:NEW.created_at, SYSTIMESTAMP);
  END IF;
  IF UPDATING THEN
    :NEW.updated_at := SYSTIMESTAMP;
  END IF;
END;
/
```

**Notes:**

* Use `BEFORE` to adjust `:NEW` values.
* Prefer CHECK constraints for simple rules; triggers for cross-column logic.

---

## 2) AFTER row trigger — change audit (old vs new)

```sql
CREATE OR REPLACE TRIGGER au_accounts_changes
AFTER INSERT OR UPDATE OR DELETE ON accounts
FOR EACH ROW
BEGIN
  INSERT INTO account_audit(
    account_id, op,
    old_email, new_email,
    old_name,  new_name,
    old_status,new_status
  )
  VALUES (
    CASE WHEN INSERTING THEN :NEW.account_id ELSE :OLD.account_id END,
    CASE WHEN INSERTING THEN 'INSERT'
         WHEN UPDATING THEN 'UPDATE'
         ELSE 'DELETE' END,
    :OLD.email, :NEW.email,
    :OLD.full_name, :NEW.full_name,
    :OLD.status, :NEW.status
  );
END;
/
```

---

## 3) Statement-level trigger — maintain summary table

```sql
CREATE TABLE acct_daily_counts (
  d DATE PRIMARY KEY,
  cnt NUMBER
);

CREATE OR REPLACE TRIGGER ai_accounts_count
AFTER INSERT ON accounts
DECLARE
BEGIN
  MERGE INTO acct_daily_counts d
  USING (SELECT TRUNC(SYSDATE) AS dd FROM dual) s
  ON (d.d = s.dd)
  WHEN MATCHED THEN UPDATE SET d.cnt = d.cnt + SQL%ROWCOUNT
  WHEN NOT MATCHED THEN INSERT (d, cnt) VALUES (s.dd, SQL%ROWCOUNT);
END;
/
```

**Note:** Statement triggers fire once per DML statement; use `SQL%ROWCOUNT`.

---

## 4) INSTEAD OF trigger — updatable view

```sql
CREATE OR REPLACE VIEW v_acct_orders AS
SELECT a.account_id, a.email, o.order_id, o.total_cents
FROM   accounts a LEFT JOIN orders o USING (account_id);

CREATE OR REPLACE TRIGGER iov_v_acct_orders
INSTEAD OF INSERT ON v_acct_orders
FOR EACH ROW
BEGIN
  INSERT INTO accounts(account_id, email)
  VALUES (:NEW.account_id, :NEW.email);

  IF :NEW.order_id IS NOT NULL THEN
    INSERT INTO orders(order_id, account_id, total_cents)
    VALUES (:NEW.order_id, :NEW.account_id, NVL(:NEW.total_cents,0));
  END IF;
END;
/
```

---

## 5) Firing order control — `FOLLOWS` (11g+)

```sql
-- Ensure audit fires after normalization trigger
CREATE OR REPLACE TRIGGER au_accounts_changes
AFTER INSERT OR UPDATE OR DELETE ON accounts
FOR EACH ROW
FOLLOWS biu_accounts_norm
BEGIN
  INSERT INTO account_audit(...) VALUES (...);
END;
/
```

---

## 6) COMPOUND trigger — avoid mutating-table errors (parent/child maintenance)

> Example: maintain a per-account “last_order_at” without querying the mutating `orders` table row-by-row.

```sql
ALTER TABLE accounts ADD last_order_at TIMESTAMP;

CREATE OR REPLACE TRIGGER ct_orders_maintain_last
FOR INSERT OR UPDATE OF created_at ON orders
COMPOUND TRIGGER
  TYPE t_acc_ids IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  g_acc_ids t_acc_ids;

  BEFORE STATEMENT IS
  BEGIN
    g_acc_ids.DELETE;
  END BEFORE STATEMENT;

  AFTER EACH ROW IS
  BEGIN
    -- Collect affected account_ids
    IF :NEW.account_id IS NOT NULL THEN
      g_acc_ids(g_acc_ids.COUNT+1) := :NEW.account_id;
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
    -- Set last_order_at in one set operation (no mutating error)
    MERGE INTO accounts a
    USING (
      SELECT account_id, MAX(created_at) last_at
      FROM   orders
      WHERE  account_id IN (SELECT COLUMN_VALUE FROM TABLE(sys.odcinumberlist
                               /* convert assoc array to nested table */
                               ))
      GROUP BY account_id
    ) o
    ON (a.account_id = o.account_id)
    WHEN MATCHED THEN UPDATE SET a.last_order_at = o.last_at;
  END AFTER STATEMENT;
END ct_orders_maintain_last;
/
```

> Implementation note: to pass `g_acc_ids` to SQL, populate a `sys.odcinumberlist` in `AFTER STATEMENT` (or use a package-level nested table). The core idea: **collect first, write once**.

---

## 7) Autonomous logging from triggers (use sparingly)

```sql
CREATE OR REPLACE TRIGGER ad_accounts_error_log
AFTER INSERT OR UPDATE OR DELETE ON accounts
DECLARE
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO log_event(level, module, action, msg)
  VALUES ('INFO','TRIGGER','accounts','DML on accounts');
  COMMIT; -- required inside autonomous block
END;
/
```

**Caution:** Keep autonomous trigger work tiny. Never perform business DML here.

---

## 8) Row-level locking in triggers — `WHERE CURRENT OF`

```sql
-- Pattern: safe per-row updates in a cursor FOR UPDATE loop, not inside trigger.
-- Inside a trigger you can reference :NEW/:OLD, but avoid firing more DML on same table unless using compound approaches.
```

---

## 9) DDL & LOGON triggers (system-level)

```sql
-- Schema-level DDL audit
CREATE OR REPLACE TRIGGER ddl_audit
AFTER DDL ON SCHEMA
BEGIN
  INSERT INTO log_event(level, module, action, msg)
  VALUES ('INFO','DDL', ora_sysevent, ora_dict_obj_owner||'.'||ora_dict_obj_name);
END;
/

-- Database LOGON: set app context
CREATE OR REPLACE TRIGGER set_context_on_logon
AFTER LOGON ON DATABASE
BEGIN
  DBMS_SESSION.SET_IDENTIFIER(SYS_CONTEXT('USERENV','SESSION_USER')||':'||SYS_CONTEXT('USERENV','SID'));
  DBMS_APPLICATION_INFO.SET_MODULE('APP','SESSION_INIT');
END;
/
```

---

## 10) Disabling/enabling, troubleshooting, and metadata

```sql
-- Disable/enable
ALTER TRIGGER biu_accounts_norm DISABLE;
ALTER TRIGGER biu_accounts_norm ENABLE;

-- Disable all triggers on a table (maintenance)
ALTER TABLE accounts DISABLE ALL TRIGGERS;
ALTER TABLE accounts ENABLE  ALL TRIGGERS;

-- Inspect
SELECT trigger_name, triggering_event, trigger_type, status
FROM   user_triggers
WHERE  table_name = 'ACCOUNTS';

-- Show trigger source
SELECT text FROM user_source
WHERE  name = 'BIU_ACCOUNTS_NORM' AND type = 'TRIGGER'
ORDER  BY line;
```

---

## 11) Useful patterns

### 11a) Prevent dangerous changes (business rule)

```sql
CREATE OR REPLACE TRIGGER bu_accounts_protect
BEFORE UPDATE OF status ON accounts
FOR EACH ROW
BEGIN
  IF :OLD.status = 'BLOCKED' AND :NEW.status <> 'BLOCKED' THEN
    RAISE_APPLICATION_ERROR(-20010,'Unblock requires supervisor workflow');
  END IF;
END;
/
```

### 11b) Shadow table for deletes (soft-delete archive)

```sql
CREATE TABLE accounts_deleted AS SELECT * FROM accounts WHERE 1=0;

CREATE OR REPLACE TRIGGER bd_accounts_archive
BEFORE DELETE ON accounts
FOR EACH ROW
BEGIN
  INSERT INTO accounts_deleted SELECT :OLD.* FROM dual;
END;
/
```

### 11c) Fill column defaults not expressible as simple DEFAULTs

```sql
CREATE OR REPLACE TRIGGER bi_orders_defaults
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
  IF :NEW.total_cents IS NULL THEN :NEW.total_cents := 0; END IF;
END;
/
```

---

## 12) Do/Don’t & performance

* **Do** prefer constraints for simple integrity; **use triggers** for cross-row logic or integration.
* **Do** use **compound triggers** to accumulate row keys and perform one set-based DML in `AFTER STATEMENT`.
* **Don’t** read/write the same table in a row-level trigger (mutating-table risk).
* **Do** keep triggers **short**; avoid remote calls and long logic.
* **Do** control firing order with `FOLLOWS` when needed.
* **Don’t** COMMIT/ROLLBACK inside normal triggers (except tiny autonomous logging).
* **Do** document each trigger’s purpose; too many hidden side-effects hurt maintainability.

