Short answer: do **two**.

Given your background (Oracle → Postgres), a single sheet gets crowded and blurs lines between “day-to-day SQL/admin” and “Postgres-specific power features.” The best split:

* **Part 1 — Core (Basics → Intermediate):** psql, roles/schemas, data types (incl. identity vs serial), constraints, CRUD + `RETURNING`, `ON CONFLICT` upserts, window functions, CTEs, indexing basics (btree, partial, expression, INCLUDE), `EXPLAIN ANALYZE`, transactions, `COPY`, backups (`pg_dump`), autovacuum 101, JSONB and FTS primers, Oracle→PG quick mappings.
* **Part 2 — Advanced / Ops & Tuning:** MVCC deep-dive, isolation levels, partitioning, advanced indexes (GIN/GiST/BRIN, opclasses), query planning & JIT, autovacuum tuning, WAL/PITR, logical/physical replication, FDWs, RLS, security hardening, connection pooling (pgBouncer), `pg_stat_*` & `pg_stat_statements`, `work_mem` sizing, JSONB/FTS advanced patterns, PL/pgSQL triggers/procedures.

I’ll start with **Part 1 (Core)** now. If that looks right, say “go” and I’ll deliver the Advanced sheet next.

# PostgreSQL Cheatsheet — Core (Basics → Intermediate)

## Connect & explore (psql)

```
psql -h HOST -U USER -d DB
\l              -- list databases
\c dbname       -- connect
\dn             -- schemas
\dt [schema.*]  -- tables
\d+ table       -- describe with storage/size
\di             -- indexes
\df [schema.*]  -- functions
\du             -- roles
\password user  -- set password
\copy t FROM 'file.csv' CSV HEADER  -- client-side import
\timing on      -- show query timings
\x on           -- expanded output
\watch 5        -- rerun last query every 5s
```

## Roles, users, schemas

```sql
-- role that can log in and create dbs
CREATE ROLE appuser LOGIN PASSWORD '...' CREATEDB;
-- grant usage on a schema & privileges
GRANT USAGE ON SCHEMA app TO appuser;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA app TO appuser;
ALTER DEFAULT PRIVILEGES IN SCHEMA app
  GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO appuser;
-- search path
ALTER ROLE appuser SET search_path = app, public;
```

## Data types you’ll use constantly

* `text` (preferred over `varchar(n)` unless you need a check)
* `numeric(p,s)`, `integer`, `bigint`, `real/double precision`
* `boolean` (true/false)
* `timestamp [with] time zone` (`timestamptz` recommended)
* `uuid` (use `gen_random_uuid()` from `pgcrypto`)
* `jsonb` (binary JSON with indexing)
* Arrays: `text[]`, `int[]`
* Enums (for small, stable sets)

### Identity vs serial (use identity)

```sql
CREATE TABLE t (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL
);
```

## Constraints & DDL patterns

```sql
CREATE TABLE account (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email text NOT NULL UNIQUE,
  status text NOT NULL CHECK (status IN ('active','disabled')),
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Partial unique (e.g., unique email only for active rows)
CREATE UNIQUE INDEX ux_email_active ON account(email) WHERE status='active';

-- Expression & covering (INCLUDE)
CREATE INDEX ix_lower_email ON account (lower(email)) INCLUDE (status);
```

## CRUD + `RETURNING`, upsert

```sql
-- insert with returning
INSERT INTO account(email,status) VALUES ('a@b.com','active')
RETURNING id, created_at;

-- upsert
INSERT INTO account(email,status)
VALUES ('a@b.com','active')
ON CONFLICT (email) DO UPDATE
  SET status = EXCLUDED.status;

-- update/delete with returning
UPDATE account SET status='disabled' WHERE id=42 RETURNING *;
DELETE FROM account WHERE id=42 RETURNING id;
```

## Query power moves

```sql
-- window functions
SELECT id, email,
       row_number() OVER (PARTITION BY status ORDER BY id) AS rn
FROM account;

-- CTEs (useful; avoid giant chains on hot paths)
WITH recent AS (
  SELECT * FROM account WHERE created_at > now() - interval '7 days'
)
SELECT status, count(*) FROM recent GROUP BY status;

-- generate_series for synthetic rows
SELECT date::date
FROM generate_series(now()-interval '6 days', now(), interval '1 day') AS date;

-- LATERAL join (dependent subquery)
SELECT a.id, j.top_tag
FROM account a
CROSS JOIN LATERAL (
  SELECT tag AS top_tag
  FROM account_tags t WHERE t.account_id = a.id ORDER BY weight DESC LIMIT 1
) j;
```

## Indexing basics (what to pick)

* **btree**: default; equality/order, most queries.
* **GIN**: arrays, `jsonb` containment (`@>`), full-text.
* **GiST**: ranges, geo, nearest-neighbor.
* **BRIN**: huge append-only tables, naturally ordered columns (fast & tiny).
* Prefer **partial** (`WHERE ...`) and **expression** indexes for targeted speedups.
* Use **INCLUDE** for covering queries.

## Plans & performance

```sql
EXPLAIN (ANALYZE, BUFFERS) SELECT ...;
SET enable_seqscan = off;   -- test planner choices (session only)
SET statement_timeout = '5s';
```

Look for: row estimates vs actuals, node times, buffer hits vs reads, nested loop explosions. Gather stats after big loads:

```sql
ANALYZE app.account;
```

## Transactions & isolation

```sql
BEGIN;
  UPDATE account SET status='active' WHERE id=1;
COMMIT;  -- or ROLLBACK

-- change isolation for the tx
BEGIN ISOLATION LEVEL REPEATABLE READ;
-- ... SELECTs see a stable snapshot
COMMIT;
```

## JSONB quick primer

```sql
-- store
CREATE TABLE evt(id bigint GENERATED BY DEFAULT AS IDENTITY, payload jsonb);
INSERT INTO evt(payload) VALUES ('{"user":{"id":7},"tags":["a","b"]}');

-- query
SELECT payload->'user'->>'id' AS user_id
FROM evt
WHERE payload @> '{"tags":["a"]}'::jsonb;   -- contains "a"

-- index for containment
CREATE INDEX ix_evt_payload_gin ON evt USING gin (payload jsonb_path_ops);
```

## Full-text search (FTS) starter

```sql
-- computed tsvector column + GIN index
ALTER TABLE doc ADD COLUMN tsv tsvector
  GENERATED ALWAYS AS (to_tsvector('english', coalesce(title,'') || ' ' || coalesce(body,''))) STORED;
CREATE INDEX ix_doc_tsv ON doc USING gin (tsv);

-- query
SELECT * FROM doc WHERE tsv @@ plainto_tsquery('english','dark money donors');
```

## psql + COPY for ETL

```sql
-- fastest bulk load
\copy staging(id,email,status) FROM 'staging.csv' CSV HEADER
-- export
\copy (SELECT * FROM account) TO 'acct.csv' CSV HEADER
```

## Backups & restore (essentials)

```bash
pg_dump -Fc -h HOST -U USER DB > db.dump             # custom format
pg_restore -d DBNEW --create --jobs=4 db.dump        # parallel restore
pg_dumpall --globals-only > globals.sql              # roles/privs
```

## Maintenance 101

* **Autovacuum** handles bloat; keep it enabled. Manual:

```sql
VACUUM (VERBOSE, ANALYZE) app.account;
REINDEX INDEX app.ix_lower_email;  -- corruption/bloat fixes
CLUSTER account USING ix_lower_email; -- reorder table physically (locks)
```

## Server knobs you’ll actually touch (per env)

* `shared_buffers` (\~25% RAM), `work_mem` (per sort/hash), `maintenance_work_mem` (index builds),
* `effective_cache_size` (\~50–75% RAM), `max_connections` (keep low; use pgBouncer),
* `wal_level`, `max_wal_size`, `checkpoint_timeout`.

*(Tune safely; measure with `pg_stat_statements`.)*

## Oracle → Postgres quick map

| Oracle                     | Postgres                                             |
| -------------------------- | ---------------------------------------------------- |
| `DUAL`                     | Not needed (`SELECT 1;`)                             |
| `SYSDATE` / `SYSTIMESTAMP` | `now()` / `clock_timestamp()`                        |
| `NUMBER`                   | `numeric`, `integer`, `bigint`                       |
| Empty `''` = NULL          | Empty `''` ≠ NULL                                    |
| Sequences & `NEXTVAL`      | `IDENTITY` (preferred) or `nextval('seq')`           |
| `MERGE`                    | `INSERT ... ON CONFLICT DO UPDATE`                   |
| `NVL`, `DECODE`            | `COALESCE`, `CASE`                                   |
| Packages                   | Schemas + functions; no package state                |
| Procedures (commit inside) | Functions (pre-11), Procedures (`CALL`) since PG11   |
| `ROWNUM` / `ROW_NUMBER`    | `LIMIT/OFFSET` / window functions                    |
| Synonyms                   | `search_path`, views                                 |
| Hints                      | Limited (`enable_*` GUCs, extensions); rely on stats |

---

If this looks good, say **“go”** and I’ll deliver the **Advanced / Ops & Tuning** sheet next (partitioning, replication, WAL/PITR, autovacuum tuning, query planner/JIT, advanced indexes, JSONB/FTS deep-dive, RLS/security, pooling, monitoring).
